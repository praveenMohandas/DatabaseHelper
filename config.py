# config.py

from sentence_transformers import SentenceTransformer
# Database connection configuration
DB_HOST = 'localhost' 
#change the following according to your database credentials
DB_PORT = 5432 
DB_NAME = 'rag_db'
DB_USER = 'test1234'
DB_PASSWORD = '1234'

# Table configuration
TABLE_NAME = 'dune_docs'

embedding_model = SentenceTransformer('sentence-transformers/all-mpnet-base-v2') # Dimension for the embedding vector

# JSONL file to ingest (update with the full path to your JSONL file)
JSONL_FILE = '/Users/praveenmohandas/Documents/dune_challenge/dune_docs.jsonl'#mention the file path for jsonl file
OPENAI_API_KEY="your API key"
EMBEDDING_DIM = 768

# config.py

# 1) LLM #1 Prompt
INTENT_PROMPT = """
You are a Dune assistant. The user may have a general query that is to be answered  or want to interact with knowledge base content(knowledge base contains infomation on Dune website).

Return strictly valid JSON:
{
  "intent": "general_purpose" or "change_knowledgebase",
  "action": "add" or "replace" or "delete" or "retrieve" or null,
  "old_feature" : extract the old feature mentioned in users query which is likely to be replaced or deleted.
  "new_feature" :  extract the new feature mentioned in users query which is likely to be replaced or added.
  "refined_query for retrieval": "string" or null
}

If intent=general_purpose, action ,old feature and new feature  are null or  action could be "retrieve" if the query is to be answered based on database content .If the query does not require knowledge from knowledge base then everything else is null .
If intent=interact_knowledgebase, action is one of [add, replace, delete, retrieve].
'retrieved_query for retrieval' is your best guess at what to search in the DB to find relevant rows using retrieval augmented generation.For example it could be find all relevant content related to old features.
No extra text or keys.
"""

# 2) LLM #2 Prompt
SECOND_LLM_PROMPT = """
You are a Dune assistant. You receive:
{
  "intent": "...",
  "action": "...",
  "old_feature": " ..",
  "new_feature": "...",
  "retrieved_context": [
    { "id": 1, "content": "...", "url": "..." } or null,
    ...
  ]
}

Return strictly valid JSON:
{
  "new_content": "string with what we want to store or use",
  "call_to_db": true or false
}
the "new_content" should be generated by you if the action is add or replace and it should be based on new feature
if the action is replace you need to make new content for the first retreieved context.
If action=add/replace/delete, likely call_to_db=true. 
If it's a general query, call_to_db=false and the new_content would be null
No extra text or keys.
"""
#for tooluse
db_operation_function = {
    "type": "function",
    "function": {
        "name": "db_operation",
        "description": (
            "You are a Dune assistant. You receive:\n"
            "    {\n"
            "        \"intent\": \"...\",\n"
            "        \"action\": \"...\",\n"
            "        \"old_feature\": \"...\",\n"
            "        \"new_feature\": \"...\",\n"
            "        \"retrieved_context\": [\n"
            "            { \"id\": 1, \"content\": \"...\", \"url\": \"...\" } or null,\n"
            "            ...\n"
            "        ]\n"
            "    }\n"
            "You have to guide to do the database operation according to the input. "
            "Supported actions: 'add', 'replace', or 'delete'.\n"
            " - For 'add': you must provide new_content.\n"
            " - For 'replace': you must provide both row_ids and new_content.\n"
            " - For 'delete': you must provide row_ids."
        ),
        "parameters": {
            "type": "object",
            "properties": {
                "action": {
                    "type": "string",
                    "description": "Must be one of: 'add', 'replace', or 'delete'."
                },
                "call_to_db": {
                    "type": "boolean",
                    "description": (
                        "Must be true or false and this decides if any action would be performed on the database. "
                        "If action is add/replace/delete, likely call_to_db=true. "
                        "If it's a general query, call_to_db=false and new_content should be null."
                    )
                },
                "row_ids": {
                    "type": "array",
                    "description": "List of integer row IDs if action is 'delete' or 'replace'.",
                    "items": {
                        "type": "integer"
                    }
                },
                "new_content": {
                    "type": "string",
                    "description": (
                        "The new content to add or replace. This should be generated based on new_feature. "
                        "If the action is replace, generate new content for the first retrieved context."
                    )
                }
            },
            "required": ["action"]
        }
    }
}


# 3) LLM #3 Prompt (Final Explanation)
THIRD_LLM_PROMPT = """
You are a Dune assistant. You've either changed or not changed the database based on the user's request.
You receive:
{ "query": original query from user 
  "intent": "general_purpose" or "change_knowledgebase"(that is the intent of the user),
  "action": "add" or "replace" or "delete" or null (that is the action that was performed in database),
  "row_ids": [1, 2, ...] (could be empty)(the row ids that was added,deleted or replaced),
  "context": context retrieved from database
  "new_content": "the new content string"(the new content added / replaced in databse)
}
and chat history

Your job is to produce a detailed  text that explains what happened:
- If intent=general_purpose, answer the query from user  and use   the context retrieved from databse  represented by "context" if it helps to answer the query.
- If action=add, say you inserted 'new_content' as a new row( explicitly mention row_ids where you get the row ids from "row_ids" parameter in input).
- If action=replace, say you replaced the existing rows ( explicitly mention row_ids where you get the row ids from "row_ids" parameter in input)with 'new_content'.
- If action=delete, say you deleted the rows( explicitly mention row_ids where you get the row ids from "row_ids" parameter in input).
- If you get the input json as completely empty it is because previous llms call has been skipped due to repetitive query from user and you also have access to chat history  so respond according to previous responses.So if the user is asking repetitve question respond accordingly from the answers you have from chat history.

The final response should be very detailed
"""
